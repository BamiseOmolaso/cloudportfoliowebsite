name: Deploy Application

on:
  # Run after CI passes (recommended - prevents deploying broken code)
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
    branches:
      - develop
      - staging
      - main
  # Also allow direct push (for flexibility)
  push:
    branches:
      - develop
      - staging
      - main
    paths-ignore:
      - 'terraform/**'
      - '**.md'
      - '.github/workflows/terraform.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev/staging/prod)'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: 'Docker image tag (leave empty for commit SHA)'
        required: false
        type: string

env:
  AWS_REGION: us-east-1

jobs:
  # ============================================
  # Build & Push Docker Image
  # ============================================
  
  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    # Only run if CI passed (when triggered by workflow_run)
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    permissions:
      contents: read
      id-token: write
      security-events: write
    outputs:
      image-tag: ${{ steps.image-tag.outputs.IMAGE_TAG }}
      image-digest: ${{ steps.build.outputs.digest }}
      ecr-repository: ${{ steps.ecr.outputs.ECR_URL }}
      environment: ${{ steps.env.outputs.ENV_NAME }}
    
    steps:
      - name: Check CI Status (if triggered by workflow_run)
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "‚ùå CI Pipeline failed. Skipping deployment."
            echo "CI Conclusion: ${{ github.event.workflow_run.conclusion }}"
            exit 1
          fi
          echo "‚úÖ CI Pipeline passed. Proceeding with deployment."
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Select environment
        id: env
        run: |
          if [[ "${{ github.event.inputs.environment }}" != "" ]]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref_name }}" == "develop" ]]; then
            ENV_NAME="dev"
          elif [[ "${{ github.ref_name }}" == "staging" ]]; then
            ENV_NAME="staging"
          elif [[ "${{ github.ref_name }}" == "main" ]]; then
            ENV_NAME="prod"
          else
            ENV_NAME="dev"
          fi
          echo "ENV_NAME=$ENV_NAME" >> $GITHUB_OUTPUT
          echo "Selected environment: $ENV_NAME"
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: docker-build-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECR Repository URL
        id: ecr
        run: |
          cd terraform/envs/${{ steps.env.outputs.ENV_NAME }}
          
          # Initialize Terraform (backend only)
          terraform init -backend-config="bucket=omolaso-terraform-state" \
                         -backend-config="key=envs/${{ steps.env.outputs.ENV_NAME }}/terraform.tfstate" \
                         -backend-config="region=${{ env.AWS_REGION }}" \
                         -backend-config="use_lockfile=true" \
                         -backend-config="encrypt=true" \
                         -input=false
          
          # Get ECR URL from outputs
          ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
          if [ -z "$ECR_URL" ]; then
            echo "‚ö†Ô∏è  ECR repository not found. Infrastructure may not be deployed yet."
            echo "ECR_URL=" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "ECR_URL=$ECR_URL" >> $GITHUB_OUTPUT
            echo "‚úÖ Found ECR repository: $ECR_URL"
          fi
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set image tag
        id: image-tag
        run: |
          if [[ "${{ github.event.inputs.image_tag }}" != "" ]]; then
            TAG="${{ github.event.inputs.image_tag }}"
          else
            TAG="${GITHUB_SHA::7}"
          fi
          echo "IMAGE_TAG=$TAG" >> $GITHUB_OUTPUT
          echo "Using image tag: $TAG"
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.ecr.outputs.ECR_URL }}
          tags: |
            type=raw,value=${{ steps.image-tag.outputs.IMAGE_TAG }}
            type=raw,value=${{ steps.env.outputs.ENV_NAME }}-latest
            type=sha,prefix=${{ steps.env.outputs.ENV_NAME }}-
          flavor: |
            suffix=-${{ steps.env.outputs.ENV_NAME }}
        if: steps.ecr.outputs.ECR_URL != ''
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
        if: steps.ecr.outputs.ECR_URL != ''
      
      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
        continue-on-error: true
        if: steps.ecr.outputs.ECR_URL != ''
      
      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v4
        if: hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: 'trivy-results.sarif'

  # ============================================
  # Deploy to ECS
  # ============================================
  
  deploy-ecs-dev:
    name: Deploy to ECS - Dev
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: |
      github.ref_name == 'develop' &&
      github.event_name == 'push' &&
      needs.build-and-push.outputs.ecr-repository != '' &&
      needs.build-and-push.result == 'success'
    environment:
      name: development
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: ecs-deploy-dev-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECS Service Info
        id: ecs
        run: |
          cd terraform/envs/dev
          
          # Retry logic for state checksum mismatch
          MAX_RETRIES=3
          RETRY_COUNT=0
          INIT_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$INIT_SUCCESS" = false ]; do
            echo "üîÑ Terraform init attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Run terraform init and capture both stdout and stderr
            terraform init -input=false -backend-config="bucket=omolaso-terraform-state" \
                              -backend-config="key=envs/dev/terraform.tfstate" \
                              -backend-config="region=${{ env.AWS_REGION }}" \
                              -backend-config="dynamodb_table=portfolio-tf-locks" \
                              -backend-config="encrypt=true" > init.log 2>&1
            INIT_EXIT_CODE=$?
            
            if [ $INIT_EXIT_CODE -eq 0 ]; then
              INIT_SUCCESS=true
              echo "‚úÖ Terraform init successful"
            else
              # Check for checksum mismatch error
              if grep -qi "checksum.*does not match\|checksum.*mismatch\|Error refreshing state.*checksum" init.log; then
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚ö†Ô∏è State checksum mismatch detected. Waiting before retry..."
                  WAIT_TIME=$((RETRY_COUNT * 30))
                  echo "‚è≥ Waiting ${WAIT_TIME} seconds for S3/DynamoDB consistency..."
                  sleep $WAIT_TIME
                  
                  # Try to fix the checksum in DynamoDB
                  echo "üîß Attempting to fix DynamoDB checksum..."
                  CALCULATED_CHECKSUM=$(grep -i "Calculated checksum:" init.log | grep -oE "[a-f0-9]{32}" | head -1 || echo "")
                  if [ -n "$CALCULATED_CHECKSUM" ]; then
                    echo "üìù Updating DynamoDB with calculated checksum: $CALCULATED_CHECKSUM"
                    # Terraform stores checksum with LockID format: {bucket}/{key}-md5
                    LOCK_ID="omolaso-terraform-state/envs/dev/terraform.tfstate-md5"
                    aws dynamodb update-item \
                      --table-name portfolio-tf-locks \
                      --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
                      --update-expression "SET Digest = :d" \
                      --expression-attribute-values "{\":d\": {\"S\": \"$CALCULATED_CHECKSUM\"}}" \
                      --region ${{ env.AWS_REGION }} 2>&1 | tee dynamodb-update.log || echo "‚ö†Ô∏è Could not update DynamoDB checksum"
                    echo "üìã DynamoDB update result:"
                    cat dynamodb-update.log || true
                  else
                    echo "‚ö†Ô∏è Could not extract calculated checksum from error message"
                    echo "üìã Error log:"
                    cat init.log
                  fi
                else
                  echo "‚ùå Max retries reached. State checksum issue persists."
                  exit 1
                fi
              else
                echo "‚ùå Terraform init failed with different error"
                cat init.log
                exit 1
              fi
            fi
          done
          
          if [ "$INIT_SUCCESS" = false ]; then
            echo "‚ùå Failed to initialize Terraform after $MAX_RETRIES attempts"
            exit 1
          fi
          
          CLUSTER=$(terraform output -raw ecs_cluster_name)
          SERVICE=$(terraform output -raw ecs_service_name)
          
          echo "cluster_name=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE" >> $GITHUB_OUTPUT
      
      - name: Update ECS Service with new image
        run: |
          # Update Terraform variable for image tag
          cd terraform/envs/dev
          terraform apply -var="image_tag=${{ needs.build-and-push.outputs.image-tag }}" \
                          -auto-approve \
                          -input=false
      
      - name: Wait for ECS Service to Stabilize
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster_name }} \
            --services ${{ steps.ecs.outputs.service_name }} \
            --region ${{ env.AWS_REGION }} \
            --max-attempts 60

  deploy-ecs-staging:
    name: Deploy to ECS - Staging
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: |
      (github.ref_name == 'staging' || github.event.inputs.environment == 'staging') &&
      needs.build-and-push.outputs.ecr-repository != '' &&
      needs.build-and-push.result == 'success'
    environment:
      name: staging
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: ecs-deploy-staging-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECS Service Info
        id: ecs
        run: |
          cd terraform/envs/staging
          
          # Retry logic for state checksum mismatch
          MAX_RETRIES=3
          RETRY_COUNT=0
          INIT_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$INIT_SUCCESS" = false ]; do
            echo "üîÑ Terraform init attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Run terraform init and capture both stdout and stderr
            terraform init -input=false -backend-config="bucket=omolaso-terraform-state" \
                              -backend-config="key=envs/staging/terraform.tfstate" \
                              -backend-config="region=${{ env.AWS_REGION }}" \
                              -backend-config="dynamodb_table=portfolio-tf-locks" \
                              -backend-config="encrypt=true" > init.log 2>&1
            INIT_EXIT_CODE=$?
            
            if [ $INIT_EXIT_CODE -eq 0 ]; then
              INIT_SUCCESS=true
              echo "‚úÖ Terraform init successful"
            else
              # Check for checksum mismatch error
              if grep -qi "checksum.*does not match\|checksum.*mismatch\|Error refreshing state.*checksum" init.log; then
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚ö†Ô∏è State checksum mismatch detected. Waiting before retry..."
                  WAIT_TIME=$((RETRY_COUNT * 30))
                  echo "‚è≥ Waiting ${WAIT_TIME} seconds for S3/DynamoDB consistency..."
                  sleep $WAIT_TIME
                  
                  # Try to fix the checksum in DynamoDB
                  echo "üîß Attempting to fix DynamoDB checksum..."
                  CALCULATED_CHECKSUM=$(grep -i "Calculated checksum:" init.log | grep -oE "[a-f0-9]{32}" | head -1 || echo "")
                  if [ -n "$CALCULATED_CHECKSUM" ]; then
                    echo "üìù Updating DynamoDB with calculated checksum: $CALCULATED_CHECKSUM"
                    # Terraform stores checksum with LockID format: {bucket}/{key}-md5
                    LOCK_ID="omolaso-terraform-state/envs/staging/terraform.tfstate-md5"
                    aws dynamodb update-item \
                      --table-name portfolio-tf-locks \
                      --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
                      --update-expression "SET Digest = :d" \
                      --expression-attribute-values "{\":d\": {\"S\": \"$CALCULATED_CHECKSUM\"}}" \
                      --region ${{ env.AWS_REGION }} 2>&1 | tee dynamodb-update.log || echo "‚ö†Ô∏è Could not update DynamoDB checksum"
                    echo "üìã DynamoDB update result:"
                    cat dynamodb-update.log || true
                  else
                    echo "‚ö†Ô∏è Could not extract calculated checksum from error message"
                    echo "üìã Error log:"
                    cat init.log
                  fi
                else
                  echo "‚ùå Max retries reached. State checksum issue persists."
                  exit 1
                fi
              else
                echo "‚ùå Terraform init failed with different error"
                cat init.log
                exit 1
              fi
            fi
          done
          
          if [ "$INIT_SUCCESS" = false ]; then
            echo "‚ùå Failed to initialize Terraform after $MAX_RETRIES attempts"
            exit 1
          fi
          
          CLUSTER=$(terraform output -raw ecs_cluster_name)
          SERVICE=$(terraform output -raw ecs_service_name)
          
          echo "cluster_name=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE" >> $GITHUB_OUTPUT
      
      - name: Update ECS Service with new image
        run: |
          cd terraform/envs/staging
          terraform apply -var="image_tag=${{ needs.build-and-push.outputs.image-tag }}" \
                          -auto-approve \
                          -input=false
      
      - name: Wait for ECS Service to Stabilize
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster_name }} \
            --services ${{ steps.ecs.outputs.service_name }} \
            --region ${{ env.AWS_REGION }} \
            --max-attempts 60

  deploy-ecs-prod:
    name: Deploy to ECS - Production
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: |
      (github.ref_name == 'main' || github.event.inputs.environment == 'prod') &&
      needs.build-and-push.outputs.ecr-repository != '' &&
      needs.build-and-push.result == 'success'
    environment:
      name: production
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: ecs-deploy-prod-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECS Service Info
        id: ecs
        run: |
          cd terraform/envs/prod
          
          # Retry logic for state checksum mismatch
          MAX_RETRIES=3
          RETRY_COUNT=0
          INIT_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$INIT_SUCCESS" = false ]; do
            echo "üîÑ Terraform init attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Run terraform init and capture both stdout and stderr
            terraform init -input=false -backend-config="bucket=omolaso-terraform-state" \
                              -backend-config="key=envs/prod/terraform.tfstate" \
                              -backend-config="region=${{ env.AWS_REGION }}" \
                              -backend-config="dynamodb_table=portfolio-tf-locks" \
                              -backend-config="encrypt=true" > init.log 2>&1
            INIT_EXIT_CODE=$?
            
            if [ $INIT_EXIT_CODE -eq 0 ]; then
              INIT_SUCCESS=true
              echo "‚úÖ Terraform init successful"
            else
              # Check for checksum mismatch error
              if grep -qi "checksum.*does not match\|checksum.*mismatch\|Error refreshing state.*checksum" init.log; then
                RETRY_COUNT=$((RETRY_COUNT + 1))
                if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                  echo "‚ö†Ô∏è State checksum mismatch detected. Waiting before retry..."
                  WAIT_TIME=$((RETRY_COUNT * 30))
                  echo "‚è≥ Waiting ${WAIT_TIME} seconds for S3/DynamoDB consistency..."
                  sleep $WAIT_TIME
                  
                  # Try to fix the checksum in DynamoDB
                  echo "üîß Attempting to fix DynamoDB checksum..."
                  CALCULATED_CHECKSUM=$(grep -i "Calculated checksum:" init.log | grep -oE "[a-f0-9]{32}" | head -1 || echo "")
                  if [ -n "$CALCULATED_CHECKSUM" ]; then
                    echo "üìù Updating DynamoDB with calculated checksum: $CALCULATED_CHECKSUM"
                    # Terraform stores checksum with LockID format: {bucket}/{key}-md5
                    LOCK_ID="omolaso-terraform-state/envs/prod/terraform.tfstate-md5"
                    aws dynamodb update-item \
                      --table-name portfolio-tf-locks \
                      --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
                      --update-expression "SET Digest = :d" \
                      --expression-attribute-values "{\":d\": {\"S\": \"$CALCULATED_CHECKSUM\"}}" \
                      --region ${{ env.AWS_REGION }} 2>&1 | tee dynamodb-update.log || echo "‚ö†Ô∏è Could not update DynamoDB checksum"
                    echo "üìã DynamoDB update result:"
                    cat dynamodb-update.log || true
                  else
                    echo "‚ö†Ô∏è Could not extract calculated checksum from error message"
                    echo "üìã Error log:"
                    cat init.log
                  fi
                else
                  echo "‚ùå Max retries reached. State checksum issue persists."
                  exit 1
                fi
              else
                echo "‚ùå Terraform init failed with different error"
                cat init.log
                exit 1
              fi
            fi
          done
          
          if [ "$INIT_SUCCESS" = false ]; then
            echo "‚ùå Failed to initialize Terraform after $MAX_RETRIES attempts"
            exit 1
          fi
          
          CLUSTER=$(terraform output -raw ecs_cluster_name)
          SERVICE=$(terraform output -raw ecs_service_name)
          
          echo "cluster_name=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE" >> $GITHUB_OUTPUT
      
      - name: Update ECS Service with new image
        run: |
          cd terraform/envs/prod
          terraform apply -var="image_tag=${{ needs.build-and-push.outputs.image-tag }}" \
                          -auto-approve \
                          -input=false
      
      - name: Wait for ECS Service to Stabilize
        run: |
          aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster_name }} \
            --services ${{ steps.ecs.outputs.service_name }} \
            --region ${{ env.AWS_REGION }} \
            --max-attempts 60
      
      - name: Verify Deployment
        run: |
          cd terraform/envs/prod
          ALB_DNS=$(terraform output -raw alb_dns_name)
          
          # Health check
          MAX_RETRIES=30
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$ALB_DNS/api/health" || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed"
              exit 0
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Waiting for health check... ($RETRY_COUNT/$MAX_RETRIES) - HTTP $HTTP_CODE"
            sleep 10
          done
          
          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          exit 1

