name: Deploy Application

on:
  # Run after CI passes (recommended - prevents deploying broken code)
  workflow_run:
    workflows: ["CI Pipeline"]
    types:
      - completed
  # Also allow direct push (for flexibility)
  push:
    branches:
      - develop
      - staging
      - main
    paths-ignore:
      - 'terraform/**'
      - '**.md'
      - '.github/workflows/terraform.yml'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy (dev/staging/prod)'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      image_tag:
        description: 'Docker image tag (leave empty for commit SHA)'
        required: false
        type: string

env:
  AWS_REGION: us-east-1

jobs:
  # ============================================
  # Build & Push Docker Image
  # ============================================
  
  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    # Only run if CI passed (when triggered by workflow_run)
    if: |
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push' ||
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success')
    permissions:
      contents: read
      id-token: write
      security-events: write
    outputs:
      image_tag: ${{ steps.image-tag.outputs.IMAGE_TAG }}
      image_digest: ${{ steps.build.outputs.digest }}
      ecr_repository: ${{ steps.ecr.outputs.ECR_URL }}
      environment: ${{ steps.env.outputs.ENV_NAME }}
    
    steps:
      - name: Check CI Status (if triggered by workflow_run)
        if: github.event_name == 'workflow_run'
        run: |
          if [ "${{ github.event.workflow_run.conclusion }}" != "success" ]; then
            echo "‚ùå CI Pipeline failed. Skipping deployment."
            echo "CI Conclusion: ${{ github.event.workflow_run.conclusion }}"
            exit 1
          fi
          echo "‚úÖ CI Pipeline passed. Proceeding with deployment."
      
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Select environment
        id: env
        run: |
          if [[ "${{ github.event.inputs.environment }}" != "" ]]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref_name }}" == "develop" ]]; then
            ENV_NAME="dev"
          elif [[ "${{ github.ref_name }}" == "staging" ]]; then
            ENV_NAME="staging"
          elif [[ "${{ github.ref_name }}" == "main" ]]; then
            ENV_NAME="prod"
          else
            ENV_NAME="dev"
          fi
          echo "ENV_NAME=$ENV_NAME" >> $GITHUB_OUTPUT
          echo "Selected environment: $ENV_NAME"
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: docker-build-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECR Repository URL
        id: ecr
        run: |
          cd terraform/envs/${{ steps.env.outputs.ENV_NAME }}
          
          # Initialize Terraform (backend config is already in backend.tf)
          terraform init -input=false
          
          # Get ECR URL from outputs
          ECR_URL=$(terraform output -raw ecr_repository_url 2>/dev/null || echo "")
          if [ -z "$ECR_URL" ]; then
            echo "‚ö†Ô∏è  ECR repository not found. Infrastructure may not be deployed yet."
            echo "ECR_URL=" >> $GITHUB_OUTPUT
            exit 1
          else
            echo "ECR_URL=$ECR_URL" >> $GITHUB_OUTPUT
            echo "‚úÖ Found ECR repository: $ECR_URL"
          fi
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Set image tag
        id: image-tag
        run: |
          if [[ "${{ github.event.inputs.image_tag }}" != "" ]]; then
            TAG="${{ github.event.inputs.image_tag }}"
          else
            TAG="${GITHUB_SHA::7}"
          fi
          echo "IMAGE_TAG=$TAG" >> $GITHUB_OUTPUT
          echo "Using image tag: $TAG"
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ steps.ecr.outputs.ECR_URL }}
          tags: |
            type=raw,value=${{ steps.image-tag.outputs.IMAGE_TAG }}
            type=raw,value=${{ steps.env.outputs.ENV_NAME }}-latest
            type=sha,prefix=${{ steps.env.outputs.ENV_NAME }}-
          flavor: |
            suffix=-${{ steps.env.outputs.ENV_NAME }}
        if: steps.ecr.outputs.ECR_URL != ''
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
        if: steps.ecr.outputs.ECR_URL != ''
      
      - name: Scan image for vulnerabilities
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ steps.meta.outputs.tags }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
          exit-code: '1'
        continue-on-error: true
        if: steps.ecr.outputs.ECR_URL != ''
      
      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v4
        if: hashFiles('trivy-results.sarif') != ''
        with:
          sarif_file: 'trivy-results.sarif'

  # ============================================
  # Deploy to ECS
  # ============================================
  
  deploy-ecs-dev:
    name: Deploy to ECS - Dev
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: |
      (github.ref_name == 'develop' || github.event.inputs.environment == 'dev') &&
      needs.build-and-push.outputs.ecr_repository != '' &&
      needs.build-and-push.result == 'success'
    environment:
      name: development
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: ecs-deploy-dev-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECS Service Info
        id: ecs
        run: |
          cd terraform/envs/dev
          terraform init -input=false
          CLUSTER=$(terraform output -raw ecs_cluster_name)
          SERVICE=$(terraform output -raw ecs_service_name)
          echo "cluster_name=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE" >> $GITHUB_OUTPUT
      
      - name: Verify Docker image exists in ECR
        run: |
          ECR_REPO=${{ needs.build-and-push.outputs.ecr_repository }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}
          
          echo "üîç Verifying image exists: $ECR_REPO:$IMAGE_TAG"
          
          # Extract repository name from full URL
          REPO_NAME=$(echo "$ECR_REPO" | sed 's|.*/||')
          
          # Check if image exists
          if aws ecr describe-images \
            --repository-name "$REPO_NAME" \
            --image-ids imageTag="$IMAGE_TAG" \
            --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "‚úÖ Image $ECR_REPO:$IMAGE_TAG exists in ECR"
          else
            echo "‚ùå Image $ECR_REPO:$IMAGE_TAG NOT FOUND in ECR!"
            echo "üìã Available images in repository:"
            aws ecr list-images --repository-name "$REPO_NAME" --region ${{ env.AWS_REGION }} || true
            echo ""
            echo "üí° The build-and-push job may have failed. Check the build-and-push job logs."
            exit 1
          fi
      
      - name: Update ECS Service with new image
        run: |
          cd terraform/envs/dev
          terraform init -input=false
          
          # Run plan first to see full error messages
          echo "üìã Running Terraform plan..."
          terraform plan \
            -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" \
            -out=tfplan \
            -input=false || {
              echo "‚ùå Terraform plan failed. Full error:"
              terraform plan -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" -input=false 2>&1 | tee plan-error.log
              exit 1
            }
          
          # Apply the plan
          echo "üöÄ Applying Terraform plan..."
          terraform apply -input=false -auto-approve tfplan
      
      - name: Wait for ECS Service to Stabilize
        run: |
          echo "‚è≥ Waiting for ECS service to stabilize (max 10 minutes)..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster_name }} \
            --services ${{ steps.ecs.outputs.service_name }} \
            --region ${{ env.AWS_REGION }} || {
              echo "‚ö†Ô∏è Service stabilization timeout or error"
              echo "Checking service status..."
              aws ecs describe-services \
                --cluster ${{ steps.ecs.outputs.cluster_name }} \
                --services ${{ steps.ecs.outputs.service_name }} \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Events:events[0:3]}' \
                --output json
              exit 1
            }
          echo "‚úÖ ECS service is stable"

  deploy-ecs-staging:
    name: Deploy to ECS - Staging
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: |
      (github.ref_name == 'staging' || github.event.inputs.environment == 'staging') &&
      needs.build-and-push.outputs.ecr_repository != '' &&
      needs.build-and-push.result == 'success'
    environment:
      name: staging
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: ecs-deploy-staging-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Get ECS Service Info
        id: ecs
        run: |
          cd terraform/envs/staging
          terraform init -input=false
          CLUSTER=$(terraform output -raw ecs_cluster_name)
          SERVICE=$(terraform output -raw ecs_service_name)
          echo "cluster_name=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE" >> $GITHUB_OUTPUT
      
      - name: Verify Docker image exists in ECR
        run: |
          ECR_REPO=${{ needs.build-and-push.outputs.ecr_repository }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}
          
          echo "üîç Verifying image exists: $ECR_REPO:$IMAGE_TAG"
          
          # Extract repository name from full URL
          REPO_NAME=$(echo "$ECR_REPO" | sed 's|.*/||')
          
          # Check if image exists
          if aws ecr describe-images \
            --repository-name "$REPO_NAME" \
            --image-ids imageTag="$IMAGE_TAG" \
            --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "‚úÖ Image $ECR_REPO:$IMAGE_TAG exists in ECR"
          else
            echo "‚ùå Image $ECR_REPO:$IMAGE_TAG NOT FOUND in ECR!"
            echo "üìã Available images in repository:"
            aws ecr list-images --repository-name "$REPO_NAME" --region ${{ env.AWS_REGION }} || true
            echo ""
            echo "üí° The build-and-push job may have failed. Check the build-and-push job logs."
            exit 1
          fi
      
      - name: Update ECS Service with new image
        run: |
          cd terraform/envs/staging
          terraform init -input=false
          
          # Run plan first to see full error messages
          echo "üìã Running Terraform plan..."
          terraform plan \
            -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" \
            -out=tfplan \
            -input=false || {
              echo "‚ùå Terraform plan failed. Full error:"
              terraform plan -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" -input=false 2>&1 | tee plan-error.log
              exit 1
            }
          
          # Apply the plan
          echo "üöÄ Applying Terraform plan..."
          terraform apply -input=false -auto-approve tfplan
      
      - name: Wait for ECS Service to Stabilize
        run: |
          echo "‚è≥ Waiting for ECS service to stabilize (max 10 minutes)..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster_name }} \
            --services ${{ steps.ecs.outputs.service_name }} \
            --region ${{ env.AWS_REGION }} || {
              echo "‚ö†Ô∏è Service stabilization timeout or error"
              echo "Checking service status..."
              aws ecs describe-services \
                --cluster ${{ steps.ecs.outputs.cluster_name }} \
                --services ${{ steps.ecs.outputs.service_name }} \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Events:events[0:3]}' \
                --output json
              exit 1
            }
          echo "‚úÖ ECS service is stable"

  deploy-ecs-prod:
    name: Deploy to ECS - Production
    runs-on: ubuntu-latest
    needs: [build-and-push]
    if: |
      (github.ref_name == 'main' || github.event.inputs.environment == 'prod') &&
      needs.build-and-push.outputs.ecr_repository != '' &&
      needs.build-and-push.result == 'success'
    environment:
      name: production
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set AWS role ARN
        id: aws-role
        env:
          ROLE_ARN: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
        run: |
          if [ -n "$ROLE_ARN" ] && [[ "$ROLE_ARN" =~ ^arn:aws:iam::[0-9]+:role/ ]]; then
            echo "role_arn=$ROLE_ARN" >> $GITHUB_OUTPUT
            echo "use_oidc=true" >> $GITHUB_OUTPUT
          else
            echo "use_oidc=false" >> $GITHUB_OUTPUT
            if [ -n "$ROLE_ARN" ]; then
              echo "‚ö†Ô∏è Warning: ROLE_ARN is set but not in valid ARN format"
            fi
          fi
      
      - name: Configure AWS credentials (OIDC)
        if: steps.aws-role.outputs.use_oidc == 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.aws-role.outputs.role_arn }}
          aws-region: ${{ env.AWS_REGION }}
          role-session-name: ecs-deploy-prod-${{ github.run_id }}
          role-skip-session-tagging: false
      
      - name: Configure AWS credentials (Access Keys)
        if: steps.aws-role.outputs.use_oidc == 'false'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.13.3
          terraform_wrapper: false
      
      - name: Get ECS Service Info
        id: ecs
        run: |
          cd terraform/envs/prod
          terraform init -input=false
          CLUSTER=$(terraform output -raw ecs_cluster_name)
          SERVICE=$(terraform output -raw ecs_service_name)
          echo "cluster_name=$CLUSTER" >> $GITHUB_OUTPUT
          echo "service_name=$SERVICE" >> $GITHUB_OUTPUT
      
      - name: Verify Docker image exists in ECR
        run: |
          ECR_REPO=${{ needs.build-and-push.outputs.ecr_repository }}
          IMAGE_TAG=${{ needs.build-and-push.outputs.image_tag }}
          
          echo "üîç Verifying image exists: $ECR_REPO:$IMAGE_TAG"
          
          # Extract repository name from full URL
          REPO_NAME=$(echo "$ECR_REPO" | sed 's|.*/||')
          
          # Check if image exists
          if aws ecr describe-images \
            --repository-name "$REPO_NAME" \
            --image-ids imageTag="$IMAGE_TAG" \
            --region ${{ env.AWS_REGION }} 2>/dev/null; then
            echo "‚úÖ Image $ECR_REPO:$IMAGE_TAG exists in ECR"
          else
            echo "‚ùå Image $ECR_REPO:$IMAGE_TAG NOT FOUND in ECR!"
            echo "üìã Available images in repository:"
            aws ecr list-images --repository-name "$REPO_NAME" --region ${{ env.AWS_REGION }} || true
            echo ""
            echo "üí° The build-and-push job may have failed. Check the build-and-push job logs."
            exit 1
          fi
      
      - name: Update ECS Service with new image
        run: |
          cd terraform/envs/prod
          terraform init -input=false
          
          # Run plan first to see full error messages
          echo "üìã Running Terraform plan..."
          terraform plan \
            -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" \
            -out=tfplan \
            -input=false || {
              echo "‚ùå Terraform plan failed. Full error:"
              terraform plan -var="image_tag=${{ needs.build-and-push.outputs.image_tag }}" -input=false 2>&1 | tee plan-error.log
              exit 1
            }
          
          # Apply the plan
          echo "üöÄ Applying Terraform plan..."
          terraform apply -input=false -auto-approve tfplan
      
      - name: Wait for ECS Service to Stabilize
        run: |
          echo "‚è≥ Waiting for ECS service to stabilize (max 10 minutes)..."
          timeout 600 aws ecs wait services-stable \
            --cluster ${{ steps.ecs.outputs.cluster_name }} \
            --services ${{ steps.ecs.outputs.service_name }} \
            --region ${{ env.AWS_REGION }} || {
              echo "‚ö†Ô∏è Service stabilization timeout or error"
              echo "Checking service status..."
              aws ecs describe-services \
                --cluster ${{ steps.ecs.outputs.cluster_name }} \
                --services ${{ steps.ecs.outputs.service_name }} \
                --region ${{ env.AWS_REGION }} \
                --query 'services[0].{Status:status,Running:runningCount,Desired:desiredCount,Events:events[0:3]}' \
                --output json
              exit 1
            }
          echo "‚úÖ ECS service is stable"
      
      - name: Verify Deployment
        run: |
          cd terraform/envs/prod
          ALB_DNS=$(terraform output -raw alb_dns_name)
          
          # Health check
          MAX_RETRIES=30
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$ALB_DNS/api/health" || echo "000")
            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Health check passed"
              exit 0
            fi
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "‚è≥ Waiting for health check... ($RETRY_COUNT/$MAX_RETRIES) - HTTP $HTTP_CODE"
            sleep 10
          done
          
          echo "‚ùå Health check failed after $MAX_RETRIES attempts"
          exit 1

